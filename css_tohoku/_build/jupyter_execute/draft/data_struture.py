#!/usr/bin/env python
# coding: utf-8

# # データ構造
# 
# 今までは、ブール値、整数、浮動小数点数、文字列という基本データ型を説明ました。ここからは、これらの基本データ型を要素としてまとめて取り扱うデータとしての構造について説明します。

# ## タプル(tuple)

# タプルは、固定長で変更不可能(immutable)な一連のPythonオブジェクトの集合です。タプルでは、構成する要素としてあらゆる型のデータを指定できます。
# 
# ### タプルの作成
# 
# タプルを作成するには、色々な方法があります。

# - コンマで値を区切ります

# In[1]:


tup= 4, 5, 6
tup


# - 構成する要素をコンマで区切り全体を括弧```(...)```で囲みます

# In[2]:


tup= (4, 5, 6)


# - ```tuple```関数で他のシーケンスとイテレータを使ってタプルに変換する

# In[3]:


str_tuple=tuple("string")
str_tuple


# - タプルのタプルも作成できます

# In[4]:


nested_tuple= (4, 5, 6), (7, 8)
nested_tuple


# - ```+```による連結する

# In[5]:


tup+str_tuple


# - ```*```による繰り返し

# In[6]:


tup*3


# ### タプルの操作

# - 文字列と同じように、タプルの要素は```[]```で参照できます。

# In[7]:


tup[0]


# In[8]:


nested_tuple[0]


# In[9]:


nested_tuple[0][0]


# - ```len```タプルを構成する要素を数えます。

# In[10]:


len(tup)


# - タプルを書き換えることはできないです。

# In[11]:


tup[0]=1


# ## リスト
# リストは、可変長で変更可能(mutable)な一連のPythonオブジェクトの集合です。つまり、タプルとは異なり、リスト内容は直接に変更できます。

# ### リストの作成
# - 構成する要素をコンマで区切り全体をかき括弧```[...]```で囲みます

# In[ ]:


list_a=[1,2,3]
list_a


# - ```list```関数で他のシーケンスとイテレータを使ってタプルに変換する

# ```{margin}
# リストとタプルは意味的に似ているので、多くの使い方を相互に使うことができます。
# ```

# In[ ]:


list_b=list(tup)
list_b


# ### リストの操作
# 
# リストはミュータブルであるため、新しい要素を追加したり、既存の要素を削除、置換したりできます。

# - ```append```による末尾への要素の追加

# In[ ]:


list_a.append(4)
list_a


# - ```insert```による特定の位置に要素を挿入

# ```{margin}
# リストとタプルにおける要素の型は一緒でなくでも構いません。
# ```

# In[ ]:


list_a.insert(1, "Weber")
list_a


# - ```extend```によるリストの連結

# In[ ]:


list_a.extend(list_b)
list_a


# - スライスによるリストの要素を書き換え

# In[ ]:


list_a[5]= "Marx"
list_a


# In[ ]:


list_a[5:]= ["Marx","Durkheim","Parsons"]
list_a


# - ```remove```による値を指定した要素を削除
# 
# ```{margin}
# 削除しよう要素が複数ある場合、remove()は最初に見つかった要素だけ削除する
# ```

# In[ ]:


list_a.remove(1)
list_a


# - ```del```による特定の位置の要素を削除
# 

# In[ ]:


del list_a[1]
list_a


# - ```pop```による指定して要素を取り出し、削除する方法

# In[ ]:


list_a.pop(1)


# - ```=```による代入

# In[ ]:


list_a[1]="Giddens"
list_a


# - ```in```による要素の有無を確認

# In[ ]:


'Weber' in list_a


# In[ ]:


'Merton' in list_a


# - ```sort```による要素の並べ替え
# 
# ```sort```メソッドはリスト内の要素を並べ替えます。 引数に何も指定しなければ昇順でとなります。
# 
# 要素が文字列なら、アルファベット順でソードされます。

# In[ ]:


list_a.sort()
list_a


# ```reverse=True```引数を追加すれば降順になります・

# In[ ]:


list_a.sort(reverse=True)
list_a


# ## セット(set)
# 
# セット(set)は、重複しない要素の集合です。
# 
# ### セットの作成
# 
# ```{margin}
# セットは一意な要素の集合なので、作成する際同じ要素は複数がいる場合、一つしか含まれないです。
# ```

# - 構成する要素をコンマで区切り全体を波括弧```{...}```で囲みます

# In[13]:


set_a={1,2,2,4}
set_a


# - ```set()```関数で作成する。

# In[17]:


set_b=set(['Durkheim', 'Giddens', 'Marx', 'Marx','Parsons', 'Weber'])
set_b


# ### セットの操作

# - ```len()```による要素数の取得

# In[23]:


len(set_a)


# - ```add()```による要素の追加

# In[24]:


set_b.add('Merton')
set_b


# - ```remove()```による要素の削除

# In[25]:


set_b.remove('Merton')
set_b


# ### セットの集合演算
# セットは、数学的な集合演算をサポートします。

# - セットの和

# In[26]:


set_b.union(set_a)


# - セットの積は、両方のセットに存在する要素が含まれます。

# In[29]:


set_b.intersection(set_a)


# ## 辞書(dict)

# 辞書（dictionary）は、キー（key）と値（value）のペアを格納するデータ構造です。キーはユニークである必要があり、値は重複して格納することができます。
# 
# 辞書はミュータブルなので、キーと値要素を追加、削除、変更することは可能です。

# ### 辞書の作成

# 辞書は波括弧```{}```で囲まれ、キーと値のペアはコロン:で区切って並べ、```{key:value}```という形で作れます。
# 
# - 辞書にキーとして使用できるのは、イミュータブル型(例えば、整数、浮動小数点数、文字列、タプルなど)しか使用できません。
# - 辞書のキーはユニークである必要があります。
# 
# 
# ```{margin}
# ```{}```でキーと値を持たない空辞書を作れます。
# ```

# In[ ]:


nation={
    "Marx": "German",
    "Weber": "German",
    "Durkheim":"France",
    "Parsons":"America"
}


# In[ ]:


birth=dict(Marx=1818, Weber=1864, Durkheim=1858, Parsons=1902)


# In[ ]:


birth=dict([("Marx",1818), ("Weber",1864), ("Durkheim",1858), ("Parsons",1902)])


# ### 辞書に要素の追加・変更

# - キーを使って要素を参照し、値を代入することで辞書に要素を追加できます。

# In[ ]:


nation["Merton"]="America"


# In[ ]:


nation


# - キーはユニークでなければならないので、キーを複数回使った場合、最後の値が辞書に保留されます。

# In[ ]:


birth["Merton"]=1911 # 間違い


# In[ ]:


birth


# In[ ]:


birth["Merton"]=1910 # 正しい値


# In[ ]:


birth


# ### 要素の取得

# - 辞書のもっとも一般的な用途は、キーを指定して、対応する値を取り出すことです。

# In[ ]:


nation["Durkheim"]


# In[ ]:


nation.get("Durkheim")


# - ```keys()```によるすべてのキーの取得

# In[ ]:


nation.keys()


# - ```values()```によるすべての値の取得

# In[ ]:


nation.values()


# - ```items()```によるキー・値ペアの取得

# In[ ]:


nation.items()


# - ```len()```による長さの取得

# In[ ]:


len(nation)


# - ```update()```による辞書の結合
# 
# ```{margin}
# 第2辞書が第1辞書と同じキーを持っている場合、```update()```による第2辞書の値が保留されます。
# ```

# In[ ]:


nation2=dict(Goffman="America", Giddens="England", Habermas="Germany")


# In[ ]:


nation.update(nation2)
nation


# - ```del```による指定したキーを持つ要素の削除

# In[ ]:


del nation['Giddens']
nation


# ````{tab-set}
# ```{tab-item} 実習問題1
# 下の表が社会学者の没年を示している。社会学者の名前をキー、没年を値として辞書を作ってください。
# 
# | 名前     | 没年 | 
# |----------|---------|
# | Marx     | 1883    |
# | Weber    | 1864    | 
# | Durkheim | 1917    | 
# 
# ```
# ```{tab-item} 実習問題2
# ```Merton```の没年である```2003```を先の辞書に追加してください。
# ```
# ```{tab-item} 実習問題3
# ```Marx```の享年を計算してください。
# ```
# 
# ````

# ## シーケンス

# これまで色々なデータ型そして操作方法を勉強しました。その中に、集約する要素が一定の順序で並んでいて、その順序(インデックス)を使ってその要素を指定できる種類のオブジェクトを**シーケンス**といいます。
# 
# シーケンスであるデータ型は以下の特徴があります。
# 
# - インデックスで要素にアクセスができます
# - スライス:要素をインデックスで範囲指定し、まとめて取得することができます
# - 長さの取得ができます
# - 要素の出現回数:```count()```メソッド を使うことで指定した要素がシーケンスに何個格納されているか調べることができます

# ````{tab-set}
# ```{tab-item} 問題
# 今まで紹介されたデータ型の中に、シーケンスであるデータ型は何ですか
# 
# ```
# 
# ````
