#!/usr/bin/env python
# coding: utf-8

# # ループ

# プログラムでは、同じ処理を繰り返し行いたい（ループさせたい）ことが多くあります。
# 
# Pythonには**while**と**for**の2種類のループがあります。

# ## 基本的なループ構造

# ### forループ

# ```for```ループはリストやタプルといった集合的データ構造に対して、それぞれの要素に順番に処理するために用いられます。

# In[1]:


t=['a','b','c','d','e']
for i in t:
    print (i)


# ### ```range()```

# ```range()```という関数を使うと連続する数値からなるデータを得ることができますので、これを用いてfor文を書くことができます。主な目的は、ループの回数を指定したり、リストやタプルを作成したりする際に範囲を指定することです。
# 
# ```range(start, stop, step)```
# 
# - ```start```: 範囲の開始値を指定します（デフォルトは$0$）
# - ```stop```:  範囲の終了値を指定します（指定した値より小さい値まで範囲が生成されます）
# - ```step```: 範囲内の値の間隔を指定します（デフォルトは$1$）

# In[2]:


for i in range(1,6):
  print (i)


# In[3]:


#startを省略した場合、デフォルトで0から開始されます。
for i in range(6):
  print (i)


# In[4]:


for i in range(1,6,2):
  print (i)


# ### ```while```文によるループ
# 
# ```while```文には、与えられたループ条件とループ対象のコードブロックを記述します。
# 
# ```while```文では```while```の後の条件式が```False```となるまで、もしくはループが```break```により明示的に終了させられるまで、そのブロックが繰り返し実行されます。

# In[5]:


x = 1
total = 0
while x <= 10:
    total += x
    x += 1
    print(x, total)


# In[6]:


x=256 
total=0
while x>0:
    if total>500:
        break
    total+=x
    x=x//2
    print(x, total)


# ## 発展的なループ構造

# ### ループ内の制御構造
# 
# ある特定の条件が満たされた場合に、ループを途中で抜けたり、終わらせたくなるときがあります。これにより、柔軟にプログラムを取り組むことができます。
# 
# #### ```continue```
# 
# ```continue```は以後の処理をとばして次の処理へいきます。以下の例では、```item==3```のとき、```print(item)```を飛ばして、```item==4```となるループに進みます。

# In[7]:


for item in t:
    if item=='c':
        continue
    print (item)


# #### ```break```
# 
# ```break```はループ自体を終了します。下の例では、```item==c```のときは```break```となり、ループが終了します。

# In[8]:


for item in t:
    if item=='c':
        break
    print (item)


# #### ```pass```
# 
# ```pass```は「何もしない」ことを示す命令です。コードブロック内で必要なアクションがないことを示す時でよく用いられます。

# In[9]:


for item in t:
    if item=='c':
        pass
    print (item)


# ````{tab-set}
# ```{tab-item} 実習問題
# ここで、ユークリッドの互除法というアルゴリズムの実装にトライしてみましょう。
# 
# ユークリッドの互除法とは、2つの整数、aとbの最大公約数を求めるアルゴリズムです。例えば、2485と1162の最大公約数を求めたい場合
# 
# $2485 \div 1162 = 2 余り 161$ 
# 
# $1162 \div 161 = 7 余り 35$ 
# 
# $161 \div 35 = 4 余り 21$ 
# 
# $35 \div 21 = 1 余り 14$
# 
# $21 \div 14 = 1 余り 7$
# 
# $14 \div 7 = 2 余り 0$
# 
# 割る数と余りを次回の割られる数と割る数にして、次々と計算し、最後に割り切れたら終わりで、最後の割る数が最大公約数です。
# 
# ```
# ````

# In[10]:


#答え
a = 2485
b = 1162


# ## 例外処理
# 
# プログラムが実行されると、実行中に予期しないエラーが発生することがあります。この場合、プログラムは停止してしまいます。
# 
# 「エラーを無視してとにかくプログラムを最後まで実行させたい」「エラーが起こるときにエラーを回避するような仕組みをプログラム自体に実装したい」といった状況もあります。
# 
# ```try-except```文を使用すると、エラーが発生した場合に特定の処理を実行し、プログラムの実行を継続することができます。
# 
# ```try-except```文の基本的な構文は以下のとおりです。
# - ```try```ブロック内には、エラーが発生する可能性があるコードが含まれます。
# 
# - エラーが発生しない場合は、```except```ブロックは実行されません。
# 
# - エラーが発生した場合は、対応する```except```ブロックが実行されます。

# ```
# try:
#     # ここにエラーが発生する可能性のあるコードを書く
# except <エラーの種類>:
#     # エラーが発生した場合に実行されるコードを書く
# 
# ```

# In[11]:


import math #sqrt(square root)関数を使うための1行
s = [1,4,16,-25,36,49,64,81,100,121,144]
#for i in range(20):
for i in s:
    print(math.sqrt(i)) 


# ここで、「```i```の値が正なら平方根を表示して、負の場合はエラーメッセージだけを表示する」という作業が必要な場合は以下のように

# In[45]:


import math
s = [1,4,16,-25,36,49,64,81,100,121,144]
for i in s:
    try:
        print(math.sqrt(i)) 
    except :    
        print("値が"+str(i)+"になったのでsqrtが計算できません")


# ````{tab-set}
# ```{tab-item} 実習問題
# 被除数が100である場合、リストの値を除数とする割り算の結果を順番に計算するプログラムを実装してください。
# - 計算結果を```print```で表示してください
# - 計算不可能の場合、ラーメッセージだけを表示してエラーが起きた回数をカウントし、計算を続けてください
# ```
# ````

# In[46]:


#答え
import math
s = [1,0,10,-25,-2,50,200]
error_count = 0 


# ## enumerate
# 
# ```for```文の繰り返し処理では、要素の順序を把握したいことがあります。
# 
# ```enumerate()```関数を利用することで、```for```文内のループ処理にインデックス番号を付与できるのです。
# 
# 2つの変数 ```i```, ```d``` が指定されています。 ```i``` には $0, 1, 2, …$ が順に代入されます。 ```val``` にはリストの要素が順に代入されます。
# 
# 

# In[30]:


my_array = [ '1番目', '2番目', '3番目']
for i, d in enumerate(my_array):
    print('インデックス: ' + str(i) + ' 内容: ' + d )


# ````{tab-set}
# ```{tab-item} 実習問題
# 以下にリストに基づいて、リストの要素を値、そのインデックスをキーとする辞書を作ってくだい。
# ```
# ````

# In[31]:


#答え
l = ['Marx', 'Weber', 'Durkheim', 'Parsons', 'Merton']


# ## zip
# 

# ```zip()```関数は、複数のイテラブル（リスト、タプル、セット、文字列など）から、要素をまとめて取り出すために使用される組み込み関数です。
# 
# 具体的に言えば、対応する位置の要素をタプルにまとめ、新しいイテラブルなオブジェクトを作成します。
# 
# 各タプルは、元のイテラブルの要素の数に基づいて作成されます。要素の数が一致しない場合は、最短のイテラブルに基づいてzipオブジェクトが作成されます。
# 

# In[35]:


numbers = [1, 2, 3]
letters = ['a', 'b', 'c']
zipped = zip(numbers, letters)
for pair in zipped:
    print(pair)


# ```zip()```関数は、新しいタプルを生成するために、各イテラブルの要素を1つずつ取り出し、ループをすることができます。
# 
# 例えば、```zip()```関数を使用して、複数のリストでループを実行することができます。

# In[ ]:


numbers = [1, 2, 3]
letters = ['a', 'b', 'c']


# In[47]:


for i, j in zip(numbers, letters):
    print(i, j)


# In[48]:


for i, j in zip(numbers, letters):
    print(j, i)


# ````{tab-set}
# ```{tab-item} 実習問題
# 2つのリストをzip関数を使ってループし、各リストの要素を合計し、その結果を新しいリストに格納するプログラムを作成してください。
# ```
# ````

# In[1]:


#答え
list_a = [1, 2, 3, 4, 5]
list_b = [6, 7, 8, 9, 10]
sum_list = []


# ## 辞書のループ処理

# 辞書の要素にわたって操作はよくあります。

# - 辞書 の全てのキーを変数```key```に代入しながら、実行文を繰り返すには次のように書きます。

# In[5]:


nation={'Marx': 'German',
 'Weber': 'German',
 'Durkheim': 'France',
 'Parsons': 'America',
 'Merton': 'America',
 'Goffman': 'America',
 'Habermas': 'Germany'}


# In[7]:


for key in nation:
    print('Name:', key, ', Nationality:', nation[key])


# - ```values```メソッドを使えば（キーを使わずに）値を1つずつ取り出すこともできます。

# In[8]:


for value in nation.values():
    print('Nationality:', value)


# - ```items```メソッドを使えばキーと値を一度に取り出すこともできます。 

# In[9]:


for key, value in nation.items():
    print('Name:', key, 'Nationality:', value)


# ````{tab-set}
# ```{tab-item} 入れ子のリストを平らにする
# 入れ子になったリストを平らにしててくだい。
# 
# list1=[1, [2, 3], [4, [5]]]
# ```
# ````
